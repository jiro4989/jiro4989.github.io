---
layout: default
title: "Rubyワンライナー"
date: 2023-10-18 20:03:00 +0900
categories: tech
---

# Rubyワンライナー

仕事でRubyワンライナーを書くことがある。
主にちょっとしたテキスト加工や、調査をする時だけだが、頻度は多い。

どうせなので、自分が良く使うワンライナーの使い方と、細かい挙動についてまとめる。

* Table of contents
{:toc}

## Rubyワンライナーを覚える意義

Rubyワンライナーを覚えておくと、武器が増える。
特に、突発的に発生した緊急度の高い作業時に役立つ。
僕の場合は、非常にタイトなスケジュールが急に設定された時や、障害対応の時などが多い。

Rubyワンライナーの構文はawkと非常に似ている。
awkもワンライナーが得意なスクリプト言語だ。
Rubyは、そんなawkよりもたくさんの機能を標準で備えている。
僕がよく使うのはCSV、JSON、日付処理などだ。
いずれも、awkで扱う時は苦労する。
awkで扱うのが面倒なデータのときはRubyを使う、といった使い分けをしている。

awkを使えると簡単な集計処理ならサクッと実装できる。
同様にrubyを使えると、CSVやJSONの簡単な処理ならサクッと実装できるようになる。
使える道具は多い方が芸の幅が広くなるので、覚えとくと約にたつ。

## 使い捨てる前提でプログラムを書く

ワンライナーは、ようは使い捨てのプログラムだ。

通常であれば丁寧にスクリプトとして実装するものを、ワンライナーとして書く必要がある。
障害対応が発生した時はまさにそんなタイミングだ。
今すぐ調査して修正しないといけない。
一分一秒が惜しい。
そんな瞬間にワンライナーを書く。

多くの場合、ワンライナーでやりたい処理は「今、自分にだけ」必要な作業だ。
だから、通常のプログラム以上に、雑に書くことが許容される。
今書いて今すぐ実行する必要があるから、変数名すらもマジックナンバーじみた極小の名前をつけがちだ。
保守性は非常に低く、翌日ワンライナーを見て処理が理解できないとかはザラだ。

でも、ワンライナーはそれでいい。
明日同じワンライナーが必要になったなら、明日また同じワンライナーを書けばいいだけだから。
ワンライナーは使い捨てのプログラムだから、明日のことは考えなくていい。
リポジトリ管理のことも考えなくていいし、リポジトリ管理してはいけない。

リポジトリで管理するプログラムは、保守するプログラムだ。
保守するプログラムは、ワンライナーで実装するべきではない。
普通にスクリプトファイルとして丁寧に実装するべきだ。
ワンライナーは、使い捨てよう。

### awkだと難しいけれどrubyだと簡単にできる処理

TODO

前置きが長くなったけれど、ここからようやくRubyワンライナーの説明をする。

## ワンライナー用のオプション

### コマンドライン引数でRubyスクリプトを実行できる `-e`

Rubyのスクリプトをコマンドライン引数で実行できる。
標準入力を扱わないのであればこれだけで良い。

```bash
ruby -e 'puts 1'     # -> 1
ruby -e 'puts 5 * 2' # -> 10
```

### 標準入力を1行ずつ扱える `-n`

awkだと特にオプションを指定せずとも標準入力を扱える。
`$0`という特殊変数に、標準入力が1行ずつセットされる。

```bash
⟩ seq 3 | awk '{print $0}'
1
2
3
```

Rubyで同様のことをするには `-n` をセットする。
`$_`という特殊変数に、標準入力が1行ずつセットされる。

```bash
⟩ seq 3 | ruby -ne 'puts $_'
1
2
3
```

### 行末の改行文字を削除する `-l`

`-n` だけだと、実は標準入力を扱いづらい。
なぜなら`$_`の末尾に改行文字もついてしまってるから。

こんな普通に文字列結合してみるとよく分かる。
改行文字のあとに文字列が追加されている。

```bash
⟩ seq 3 | ruby -ne 'puts $_ + " sushi"'
1
 sushi
2
 sushi
3
 sushi
```

この改行文字を除外するには `-l` を指定する。

```bash
⟩ seq 3 | ruby -lne 'puts $_ + " sushi"'
1 sushi
2 sushi
3 sushi
```

### 標準入力を複数列の配列として扱う `-a` (と `-F`)

awkでは、標準入力で渡された文字列を`$0`変数に1行ずつセットする。
そして、空白で区切られた列データとして、`$1`, `$2`といった数値変数にもセットする。

```bash
⟩ seq 9 | paste -d ' ' - - -
1 2 3
4 5 6
7 8 9

⟩ seq 9 | paste -d ' ' - - - | awk '{print $1 " | " $2 " | " $3}'
1 | 2 | 3
4 | 5 | 6
7 | 8 | 9
```

これと同様の処理をするのにRubyでは`-a`を指定する。
特殊変数`$F`に、配列としてセットされる。

```bash
⟩ seq 9 | paste -d ' ' - - - | ruby -lane 'puts $F[0]'
1
4
7

⟩ seq 9 | paste -d ' ' - - - | ruby -lane 'puts $F[1]'
2
5
8
```

列の区切り文字を指定するのは、awkと同じで`-F`で指定する。

```bash
⟩ seq 9 | paste -d ',' - - -
1,2,3
4,5,6
7,8,9

⟩ seq 9 | paste -d ',' - - - | ruby -F, -lane 'puts $F[1]'
2
5
8
```

注意点としては、区切り文字を`-F`に隣接させないといけない。
`-F,`はOKだが、`-F ,`はエラーになる。

```bash
⟩ seq 9 | paste -d ',' - - - | ruby -F , -lane 'puts $F[1]'
ruby: No such file or directory -- , (LoadError)
```

### 困ったらとりあえず `-lane` でいい

とりあえず`-lane`って指定しとけばいい。
awkとほぼ同じ感覚で標準入力を扱えるのでおすすめ。

```bash
⟩ seq 9 | paste -d ' ' - - - | ruby -lane 'puts $F[1]'
2
5
8

⟩ seq 9 | paste -d ',' - - - | ruby -lane 'puts "<" + $_ + ">"'
<1,2,3>
<4,5,6>
<7,8,9>
```

## ユースケース

### 数値の合計

配列変数では map メソッドが使用できる。
map メソッドを使うことで、配列の要素1つずつを加工して、別の型に変更できる。
これを利用して数値型に変換すれば、数値の合計を算出できる。

```bash
⟩ seq -s ' ' 10
1 2 3 4 5 6 7 8 9 10

⟩ seq -s ' ' 10 | ruby -lane 'puts $F.map{|s| s.to_i}.sum'
55
```

前述の `s.to_i` では、String クラスの `to_i` メソッドを呼び出している。
こういったメソッド呼び出しは `&:to_i` という具合に省略して書くこともできる。
ただし、引数が必要なメソッドだとこの書き方はできない。

```bash
⟩ seq -s ' ' 10 | ruby -lane 'puts $F.map(&:to_i).sum'
55
```

`seq -s ' ' 10` は、1行に半角スペース区切りで数値を並べる。
1行ずつ数値が渡されるケースに対応するなら、以下のように書く。
awkと同様に、BEGIN、ENDブロックが使える。
ただしセミコロンで区切る必要がある。

```bash
⟩ seq 10 | ruby -lane 'BEGIN{ a = [] }; a.append($_.to_i); END{ puts a.sum }'
55
```

awkであれば、いきなり未初期化変数に対して代入ができる。
Rubyだと、そういった雑なコードは書けない。
かならず変数の初期化が必要である。

```bash
⟩ seq 10 | awk '{ a += $0 } END{ print a }'
55

# 変数 a は初期化してないのでエラーになる
⟩ seq 10 | ruby -lane 'a.append($_.to_i); END{ puts a.sum }'
-e:1:in `<main>': undefined local variable or method `a' for main:Object (NameError)
```

なお「変数が未定義の時だけ代入する」といった式も書ける。
この書き方ならBEGINブロックを省略できる。

```bash
⟩ seq 10 | ruby -lane 'a ||= []; a.append($_.to_i); END{ puts a.sum }'
55
```

### 数値の平均

前述の数値の合計に対して、配列変数 `$F` の長さで割ってやれば平均が出せる。
この時、左辺か右辺のどちらかを浮動小数点数 Float 型に変換しておく必要がある。
整数型変数のメソッド `to_f` を使えば Float 型に変換できる。

```bash
⟩ seq -s ' ' 10 | ruby -lane 'puts $F.map{|s| s.to_i}.sum.to_f / $F.length'
5.5
```

整数を整数で割ると、戻り値が整数になってしまう。

```bash
⟩ seq -s ' ' 10 | ruby -lane 'puts $F.map{|s| s.to_i}.sum / $F.length'
5
```

### GroupByして合計

これもawkと違って明示的にHashMapの変数を宣言しないといけない。

```bash
cat << EOS | ruby -lane 'a ||= {}; a[$F[0]] ||= 0; a[$F[0]] += $F[1].to_i; END{ puts a }'
aaa 100
bbb 200
aaa 100
ccc 300
bbb 200
ccc 300
EOS

{"aaa"=>200, "bbb"=>400, "ccc"=>600}
```

### 特定の文字列が存在する行だけ出力

後置ifで正規表現を書ける。
`/正規表現/`と書くだけ。

```bash
⟩ seq 10 | ruby -lane 'puts $_ if ~ /[2468]/'

2
4
6
8

# awkだとこう書く
⟩ seq 10 | awk '/[2468]/'
2
4
6
8
```

### CSVの2列目を取得

RubyではCSVクラスを使うことで、CSVを簡単に扱える。

CSVはカンマ区切りのデータだけれど、セル内にもカンマが含まれてうる。
カンマ混じりのCSVをawkだけで扱うのはかなり難しいが、Rubyだと簡単に処理できる。

```bash
⟩ echo '"hello,world","sushi,maguro","konbanwa"' | ruby -rcsv -e 'CSV(STDIN).each{|a| puts a[1]}'
sushi,maguro
```

### 特定の日付の期間のログを抽出

RubyではTimeクラスを使うことで、日付を簡単に扱える。
日付文字列のパースや、日付オブジェクトを生成したりできる。

ログファイルで特定の日付以降のログだけ抽出といった処理が書ける。
もちろんタイムゾーンも指定できるため、時差を考慮した抽出が可能。

```bash
⟩ cat << EOS | ruby -rtime -lane 'puts $_ if Time.new(2021, 2, 1, 9, 0, 0, "+09:00") < Time.parse($F[0])'
2021-01-01T11:12:30Z hello1
2021-01-02T11:12:30Z hello2
2021-01-05T11:12:30Z hello3
2021-02-01T00:00:00Z 0ji 0byou
2021-02-01T00:00:01Z 0ji 1byou
2021-02-05T20:23:30Z hello4
2021-02-11T01:23:30Z hello5
2021-02-19T12:33:30Z hello6
2021-03-02T06:23:30Z hello7
2021-03-13T13:56:30Z hello8
2021-03-21T09:41:30Z hello9
EOS

2021-02-01T00:00:01Z 0ji 1byou
2021-02-05T20:23:30Z hello4
2021-02-11T01:23:30Z hello5
2021-02-19T12:33:30Z hello6
2021-03-02T06:23:30Z hello7
2021-03-13T13:56:30Z hello8
2021-03-21T09:41:30Z hello9
```

## 標準ライブラリ

僕がワンライナーで扱うデータのうち、Rubyの標準ライブラリを使うことで簡単に処理できるのはCSV、JSONそして日付の3つだ。
それ以外にも、Rubyは多数の標準ライブラリを備えている。

[ライブラリ一覧](https://docs.ruby-lang.org/ja/latest/library/index.html)に、標準で使えるライブラリが載っている。
ここのライブラリの名前だけでも覚えておけば、有事の際に役に立つだろう。

## 参考

* [Rubyで使われる記号の意味（正規表現の複雑な記号は除く） - Ruby 3.2 リファレンスマニュアル](https://docs.ruby-lang.org/ja/latest/doc/symref.html)
